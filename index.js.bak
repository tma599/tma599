require('dotenv').config();
const fsp = require('fs/promises');
const path = require('path');
const cron = require('node-cron');

const {
  Client,
  GatewayIntentBits,
  SlashCommandBuilder,
  EmbedBuilder,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  Events,
  REST,
  Routes,
  PermissionsBitField,
  ChannelType,
  MessageFlags,
} = require('discord.js');

const intents = [
  GatewayIntentBits.Guilds,
  GatewayIntentBits.GuildMembers,
  GatewayIntentBits.GuildMessages,
  GatewayIntentBits.MessageContent,
].filter(Boolean);

const client = new Client({
  intents: intents,
});

const schedulesFilePath = path.join(__dirname, 'schedules.json');
let backupSchedules = new Map();

// ãƒ¦ãƒ¼ã‚¶ãƒ¼ã”ã¨ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’å–å¾—
const getBackupDir = (userId) => {
  return path.join(__dirname, 'backups', userId);
};

// ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å­˜åœ¨ç¢ºèªã€ãªã‘ã‚Œã°ä½œæˆ
const ensureBackupDir = async (userId) => {
  const backupDir = getBackupDir(userId);
  try {
    await fsp.mkdir(backupDir, { recursive: true });
  } catch (error) {
    console.error(
      `[ã‚¨ãƒ©ãƒ¼] ãƒ¦ãƒ¼ã‚¶ãƒ¼ID ${userId} ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚`,
      error
    );
    throw new Error('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
  }
};

// --- ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰ã®å®šç¾© ---
const commands = [
  new SlashCommandBuilder()
    .setName('help')
    .setDescription('ã“ã®ãƒœãƒƒãƒˆã®ã‚³ãƒãƒ³ãƒ‰ã«ã¤ã„ã¦ã®è©³ç´°ãªãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚'),
  new SlashCommandBuilder().setName('server').setDescription('ã‚µãƒ¼ãƒãƒ¼ã®æƒ…å ±ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚'),
  new SlashCommandBuilder()
    .setName('backup')
    .setDescription('ã‚µãƒ¼ãƒãƒ¼ã®æ§‹æˆã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã—ã¾ã™ã€‚')
    .setDefaultMemberPermissions(PermissionsBitField.Flags.ManageGuild)
    .addStringOption((option) =>
      option
        .setName('name')
        .setDescription('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç”¨ã®ãƒ•ã‚¡ã‚¤ãƒ«åã‚’æŒ‡å®šã—ã¾ã™ã€‚')
        .setRequired(true)
    ),
  new SlashCommandBuilder()
    .setName('restore')
    .setDescription('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰ã‚µãƒ¼ãƒãƒ¼ã‚’å¾©å…ƒã—ã¾ã™ã€‚')
    .setDefaultMemberPermissions(PermissionsBitField.Flags.ManageGuild)
    .addStringOption((option) =>
      option
        .setName('name')
        .setDescription('å¾©å…ƒã«ä½¿ã†ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ãƒ•ã‚¡ã‚¤ãƒ«åã‚’æŒ‡å®šã—ã¾ã™ã€‚')
        .setRequired(true)
        .setAutocomplete(true)
    ),
  new SlashCommandBuilder()
    .setName('create-template')
    .setDescription('ã‚ªãƒ¼ãƒŠãƒ¼ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã§ã‚µãƒ¼ãƒãƒ¼ã‚’ä¸Šæ›¸ãæ§‹ç¯‰ã—ã¾ã™ã€‚')
    .setDefaultMemberPermissions(PermissionsBitField.Flags.ManageGuild),
  new SlashCommandBuilder()
    .setName('backup-manage')
    .setDescription('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã®ç®¡ç†ã‚’è¡Œã„ã¾ã™ã€‚')
    .setDefaultMemberPermissions(PermissionsBitField.Flags.ManageGuild)
    .addStringOption((option) =>
      option
        .setName('action')
        .setDescription('å®Ÿè¡Œã™ã‚‹æ“ä½œã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚')
        .setRequired(true)
        .addChoices(
          { name: 'list', value: 'list' },
          { name: 'lock', value: 'lock' },
          { name: 'unlock', value: 'unlock' },
          { name: 'delete', value: 'delete' }
        )
    )
    .addStringOption((option) =>
      option
        .setName('name')
        .setDescription('å¯¾è±¡ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«å (lock, unlock, delete ã®å ´åˆ)')
        .setRequired(false)
        .setAutocomplete(true)
    ),
  new SlashCommandBuilder()
    .setName('backuptimer-manage')
    .setDescription('è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ç®¡ç†ã‚’è¡Œã„ã¾ã™ã€‚')
    .setDefaultMemberPermissions(PermissionsBitField.Flags.ManageGuild)
    .addStringOption((option) =>
      option
        .setName('action')
        .setDescription('å®Ÿè¡Œã™ã‚‹æ“ä½œã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚')
        .setRequired(true)
        .addChoices(
          { name: 'on', value: 'on' },
          { name: 'off', value: 'off' },
          { name: 'list', value: 'list' }
        )
    ),
  new SlashCommandBuilder()
    .setName('deletemessage')
    .setDescription('æŒ‡å®šã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŒ‡å®šã•ã‚ŒãŸä»¶æ•°å‰Šé™¤ã—ã¾ã™ã€‚')
    .setDefaultMemberPermissions(PermissionsBitField.Flags.ManageMessages)
    .addUserOption((option) =>
      option
        .setName('user')
        .setDescription('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‰Šé™¤ã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æŒ‡å®šã—ã¾ã™ã€‚')
        .setRequired(true)
    )
    .addIntegerOption((option) =>
      option
        .setName('count')
        .setDescription('å‰Šé™¤ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ä»¶æ•°ã‚’æŒ‡å®šã—ã¾ã™ã€‚(æœ€å¤§100ä»¶)')
        .setRequired(true)
        .setMinValue(1)
        .setMaxValue(100)
    ),
  new SlashCommandBuilder()
    .setName('backuptimer')
    .setDescription('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®è‡ªå‹•ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¨­å®šã—ã¾ã™ã€‚')
    .setDefaultMemberPermissions(PermissionsBitField.Flags.ManageGuild)
    .addStringOption((option) =>
      option
        .setName('schedule')
        .setDescription('ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¨­å®šã—ã¾ã™ã€‚')
        .setRequired(true)
        .addChoices({ name: 'everyday', value: 'everyday' })
    )
    .addStringOption((option) =>
      option
        .setName('time')
        .setDescription('æ™‚é–“å¸¯ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚')
        .setRequired(true)
        .addChoices({ name: 'AM', value: 'AM' }, { name: 'PM', value: 'PM' })
    )
    .addIntegerOption((option) =>
      option
        .setName('hour')
        .setDescription('æ™‚é–“ (0-23)')
        .setRequired(true)
        .setMinValue(0)
        .setMaxValue(23)
    )
    .addIntegerOption((option) =>
      option
        .setName('minute')
        .setDescription('åˆ† (0-59)')
        .setRequired(true)
        .setMinValue(0)
        .setMaxValue(59)
    ),
].map((cmd) => cmd.toJSON());

const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_TOKEN);
const USE_GLOBAL = false;

// --- ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼ ---
client.once(Events.ClientReady, async () => {
  console.log('--------------------------------------------------');
  console.log(`[èµ·å‹•] ${client.user.tag} ãŒèµ·å‹•ã—ã¾ã—ãŸã€‚`);
  console.log('[èµ·å‹•] ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰ã‚’ç™»éŒ²ã—ã¾ã™ã€‚');
  try {
    if (USE_GLOBAL) {
      await rest.put(Routes.applicationCommands(client.user.id), { body: commands });
      console.log('[èµ·å‹•] ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰ã‚’ç™»éŒ²ã—ã¾ã—ãŸã€‚');
    } else {
      for (const guild of client.guilds.cache.values()) {
        await guild.commands.set(commands);
        console.log(`[èµ·å‹•] ã‚®ãƒ«ãƒ‰ "${guild.name}" ã«ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰ã‚’ç™»éŒ²ã—ã¾ã—ãŸã€‚`);
      }
    }
    console.log('[èµ·å‹•] ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰ã®ç™»éŒ²ãŒå®Œäº†ã—ã¾ã—ãŸã€‚');
    await loadSchedules();
    console.log('--------------------------------------------------');
  } catch (err) {
    console.error('[ã‚¨ãƒ©ãƒ¼] ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰ã®ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸã€‚', err);
  }
});

if (!process.env.DISCORD_TOKEN) {
  console.error('DISCORD_TOKENãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚');
  process.exit(1);
}

client.on(Events.GuildCreate, async (guild) => {
  if (USE_GLOBAL) return;
  try {
    await guild.commands.set(commands);
    console.log(`[å‚åŠ ] æ–°ã—ã„ã‚®ãƒ«ãƒ‰ "${guild.name}" ã«å‚åŠ ã—ã€ã‚³ãƒãƒ³ãƒ‰ã‚’ç™»éŒ²ã—ã¾ã—ãŸã€‚`);
  } catch (err) {
    console.error(`[ã‚¨ãƒ©ãƒ¼] æ–°ã—ã„ã‚®ãƒ«ãƒ‰ "${guild.name}" ã§ã®ã‚³ãƒãƒ³ãƒ‰ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸã€‚`, err);
  }
});

client.on(Events.MessageUpdate, async (oldMessage, newMessage) => {
  if (newMessage.author.bot || newMessage.system || oldMessage.content === newMessage.content) {
    return;
  }
  if (oldMessage.partial) {
    try {
      oldMessage = await oldMessage.fetch();
    } catch (error) {
      console.error(
        `[ã‚¨ãƒ©ãƒ¼] ç·¨é›†å‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ (ID: ${oldMessage.id})`,
        error
      );
      return;
    }
  }
  const userTag = newMessage.author.tag;
  const userId = newMessage.author.id;
  const channelName = newMessage.channel.name;
  const oldContent = oldMessage.content || '[å†…å®¹ãªã—]';
  const newContent = newMessage.content || '[å†…å®¹ãªã—]';
  const messageURL = `https://discord.com/channels/${newMessage.guildId}/${newMessage.channelId}/${newMessage.id}`;
  console.log('--------------------------------------------------');
  console.log('[ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç·¨é›†æ¤œçŸ¥]');
  console.log(`ãƒ¦ãƒ¼ã‚¶ãƒ¼: ${userTag} (ID: ${userId})`);
  console.log(`ãƒãƒ£ãƒ³ãƒãƒ«: #${channelName}`);
  console.log(`ç·¨é›†å‰ã®å†…å®¹: ${oldContent}`);
  console.log(`ç·¨é›†å¾Œã®å†…å®¹: ${newContent}`);
  console.log(`ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸URL: ${messageURL}`);
  console.log('--------------------------------------------------');
});

client.on(Events.MessageDelete, async (message) => {
  if (message.partial) {
    console.log('[ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‰Šé™¤æ¤œçŸ¥] ã‚­ãƒ£ãƒƒã‚·ãƒ¥å¤–ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸã€‚');
    return;
  }
  const userTag = message.author ? message.author.tag : 'ä¸æ˜ãªãƒ¦ãƒ¼ã‚¶ãƒ¼';
  const userId = message.author ? message.author.id : 'ä¸æ˜ãªID';
  const channelName = message.channel ? message.channel.name : 'ä¸æ˜ãªãƒãƒ£ãƒ³ãƒãƒ«';
  const channelId = message.channel ? message.channel.id : 'ä¸æ˜ãªID';
  const deletedContent = message.content || '[å†…å®¹ãªã—]';
  const messageId = message.id;
  const messageURL = `https://discord.com/channels/${message.guildId}/${message.channelId}/${message.id}`;
  let attachmentURLs = [];
  if (message.attachments.size > 0) {
    attachmentURLs = message.attachments.map((attachment) => attachment.url);
  }
  console.log('--------------------------------------------------');
  console.log('[ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‰Šé™¤æ¤œçŸ¥]');
  console.log(`é€ä¿¡è€…: ${userTag} (ID: ${userId})`);
  console.log(`ãƒãƒ£ãƒ³ãƒãƒ«: #${channelName} (ID: ${channelId})`);
  console.log(`å‰Šé™¤ã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…å®¹: ${deletedContent}`);
  if (attachmentURLs.length > 0) {
    console.log(`æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«URL: ${attachmentURLs.join(', ')}`);
  }
  console.log(`ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ID: ${messageId}`);
  console.log(`ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸URL: ${messageURL}`);
  console.log('--------------------------------------------------');
});

function logCommand(interaction) {
  const user = interaction.user;
  const commandName = interaction.commandName;
  const options = interaction.options.data.map((opt) => `${opt.name}: ${opt.value}`).join(' ');
  const guild = interaction.guild;
  console.log(
    `[ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ] ãƒ¦ãƒ¼ã‚¶ãƒ¼: ${user.tag} (ID: ${user.id}) | ã‚³ãƒãƒ³ãƒ‰: /${commandName} ${options} | ã‚µãƒ¼ãƒãƒ¼: ${guild.name} (ID: ${guild.id})`
  );
}

client.on(Events.InteractionCreate, async (interaction) => {
  if (interaction.isAutocomplete()) {
    const focusedOption = interaction.options.getFocused(true);
    if (focusedOption.name === 'name') {
      const backupDir = getBackupDir(interaction.user.id);
      try {
        await fsp.access(backupDir);
        const files = await fsp.readdir(backupDir);
        const choices = files
          .filter((file) => file.endsWith('.json') && file.startsWith(focusedOption.value))
          .map((file) => file.replace('.json', ''));
        await interaction.respond(choices.map((choice) => ({ name: choice, value: choice })));
      } catch {
        await interaction.respond([]);
      }
    }
  }

  if (!interaction.isChatInputCommand()) return;
  if (!interaction.guild || !interaction.inCachedGuild()) {
    return interaction.reply({
      content: 'ã“ã®ã‚³ãƒãƒ³ãƒ‰ã¯ã‚µãƒ¼ãƒãƒ¼å†…ã§ã®ã¿ä½¿ç”¨ã§ãã¾ã™ã€‚',
      flags: MessageFlags.Ephemeral,
    });
  }

  logCommand(interaction);
  const { commandName } = interaction;

  try {
    if (commandName === 'help') {
      await handleHelpCommand(interaction);
    } else if (commandName === 'server') {
      await handleServerCommand(interaction);
    } else if (commandName === 'backup') {
      await handleBackupCommand(interaction);
    } else if (commandName === 'restore') {
      await handleRestoreCommand(interaction);
    } else if (commandName === 'backup-manage') {
      await handleBackupManageCommand(interaction);
    } else if (commandName === 'create-template') {
      await handleCreateTemplateCommand(interaction);
    } else if (commandName === 'deletemessage') {
      await handleDeleteMessageCommand(interaction);
    } else if (commandName === 'backuptimer') {
      await handleBackupTimerCommand(interaction);
    } else if (commandName === 'backuptimer-manage') {
      await handleBackupTimerManageCommand(interaction);
    }
  } catch (error) {
    console.error('[ã‚¨ãƒ©ãƒ¼] ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œä¸­ã«äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', error);
    const replyOptions = {
      content: 'ã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œä¸­ã«äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚',
      flags: MessageFlags.Ephemeral,
    };
    if (interaction.replied || interaction.deferred) {
      await interaction.followUp(replyOptions);
    } else {
      await interaction.reply(replyOptions);
    }
  }
});

// --- å¾©å…ƒå‡¦ç†ã®å…±é€šé–¢æ•° ---
async function applyBackup(guild, backupData, isTemplate = false) {
  console.log(`[å¾©å…ƒ] ã‚µãƒ¼ãƒãƒ¼ "${guild.name}" (ID: ${guild.id}) ã®å¾©å…ƒå‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™ã€‚`);
  const createdRoles = new Map();

  console.log('[å¾©å…ƒ] ãƒ­ãƒ¼ãƒ«ã®å¾©å…ƒã‚’é–‹å§‹ã—ã¾ã™ã€‚');
  for (const roleData of backupData.roles.reverse()) {
    try {
      const existingRole = guild.roles.cache.find((r) => r.name === roleData.name);
      let newRole;
      if (!existingRole) {
        console.log(`[å¾©å…ƒ] ãƒ­ãƒ¼ãƒ« "${roleData.name}" ã‚’ä½œæˆã—ã¾ã™ã€‚`);
        newRole = await guild.roles.create({
          name: roleData.name,
          color: roleData.color,
          permissions: BigInt(roleData.permissions),
          hoist: roleData.hoist,
          mentionable: roleData.mentionable,
          position: roleData.position,
        });
      } else {
        console.log(`[å¾©å…ƒ] æ—¢å­˜ã®ãƒ­ãƒ¼ãƒ« "${roleData.name}" ã‚’æ›´æ–°ã—ã¾ã™ã€‚`);
        await existingRole.edit({
          color: roleData.color,
          permissions: BigInt(roleData.permissions),
          hoist: roleData.hoist,
          mentionable: roleData.mentionable,
        });
        newRole = existingRole;
      }
      createdRoles.set(roleData.name, newRole);

      if (!isTemplate && roleData.members && roleData.members.length > 0) {
        console.log(`[å¾©å…ƒ] ãƒ­ãƒ¼ãƒ« "${roleData.name}" ã®ãƒ¡ãƒ³ãƒãƒ¼ã‚’å¾©å…ƒã—ã¾ã™ã€‚`);
        for (const memberId of roleData.members) {
          try {
            const member = await guild.members.fetch(memberId);
            if (member) {
              try {
                await member.roles.add(newRole);
              } catch (err) {
                console.error(
                  `[ã‚¨ãƒ©ãƒ¼] ãƒ¦ãƒ¼ã‚¶ãƒ¼ "${member.user.tag}" ã¸ã®ãƒ­ãƒ¼ãƒ« "${newRole.name}" ã®ä»˜ä¸ã«å¤±æ•—ã—ã¾ã—ãŸã€‚Botã®ãƒ­ãƒ¼ãƒ«ãŒå¯¾è±¡ãƒ­ãƒ¼ãƒ«ã‚ˆã‚Šä¸‹ã«ã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚`,
                  err.message
                );
              }
            }
          } catch (err) {
            if (err.code !== 10007) {
              console.error(
                `[ã‚¨ãƒ©ãƒ¼] ãƒ¡ãƒ³ãƒãƒ¼ (ID: ${memberId}) ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚`,
                err.message
              );
            }
          }
        }
      }
    } catch (err) {
      console.error(
        `[ã‚¨ãƒ©ãƒ¼] ãƒ­ãƒ¼ãƒ« "${roleData.name}" ã®ä½œæˆã¾ãŸã¯ç·¨é›†ã«å¤±æ•—ã—ã¾ã—ãŸã€‚Botã®ãƒ­ãƒ¼ãƒ«ãŒå¯¾è±¡ãƒ­ãƒ¼ãƒ«ã‚ˆã‚Šä¸‹ã«ã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚`,
        err.message
      );
    }
  }
  console.log('[å¾©å…ƒ] ãƒ­ãƒ¼ãƒ«ã®å¾©å…ƒãŒå®Œäº†ã—ã¾ã—ãŸã€‚');

  console.log('[å¾©å…ƒ] ãƒãƒ£ãƒ³ãƒãƒ«ã®å¾©å…ƒã‚’é–‹å§‹ã—ã¾ã™ã€‚');
  const createdChannels = new Map();
  const threadChannelTypes = [
    ChannelType.GuildPublicThread,
    ChannelType.GuildPrivateThread,
    ChannelType.GuildNewsThread,
  ];
  const regularChannelsData = backupData.channels.filter(
    (c) => !threadChannelTypes.includes(c.type)
  );
  const threadChannelsData = backupData.channels.filter((c) => threadChannelTypes.includes(c.type));

  for (const channelData of regularChannelsData.filter(
    (c) => c.type === ChannelType.GuildCategory
  )) {
    try {
      const existingChannel = guild.channels.cache.find(
        (c) => c.name === channelData.name && c.type === channelData.type
      );
      if (!existingChannel) {
        console.log(`[å¾©å…ƒ] ã‚«ãƒ†ã‚´ãƒª "${channelData.name}" ã‚’ä½œæˆã—ã¾ã™ã€‚`);
        const newChannel = await guild.channels.create({
          name: channelData.name,
          type: channelData.type,
          position: channelData.position,
        });
        createdChannels.set(channelData.name, newChannel);
      } else {
        console.log(`[å¾©å…ƒ] æ—¢å­˜ã®ã‚«ãƒ†ã‚´ãƒª "${channelData.name}" ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚`);
        createdChannels.set(channelData.name, existingChannel);
      }
    } catch (err) {
      console.error(`[ã‚¨ãƒ©ãƒ¼] ã‚«ãƒ†ã‚´ãƒª "${channelData.name}" ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚`, err.message);
    }
  }

  for (const channelData of regularChannelsData.filter(
    (c) => c.type !== ChannelType.GuildCategory
  )) {
    try {
      let existingChannel = guild.channels.cache.find(
        (c) => c.name === channelData.name && c.type === channelData.type
      );
      let newChannel = existingChannel;

      if (!existingChannel) {
        const parent = channelData.parent
          ? createdChannels.get(channelData.parent) ||
            guild.channels.cache.find(
              (c) => c.name === channelData.parent && c.type === ChannelType.GuildCategory
            )
          : null;
        console.log(
          `[å¾©å…ƒ] ãƒãƒ£ãƒ³ãƒãƒ« "${channelData.name}" ã‚’ä½œæˆã—ã¾ã™ã€‚${parent ? `(è¦ªã‚«ãƒ†ã‚´ãƒª: ${parent.name})` : ''}`
        );
        newChannel = await guild.channels.create({
          name: channelData.name,
          type: channelData.type,
          parent: parent ? parent.id : null,
          position: channelData.position,
        });
        createdChannels.set(channelData.name, newChannel);
      } else {
        console.log(`[å¾©å…ƒ] æ—¢å­˜ã®ãƒãƒ£ãƒ³ãƒãƒ« "${channelData.name}" ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚`);
        createdChannels.set(channelData.name, existingChannel);
      }

      if (
        newChannel &&
        newChannel.isTextBased() &&
        channelData.messages &&
        channelData.messages.length > 0
      ) {
        console.log(
          `[å¾©å…ƒ] ãƒãƒ£ãƒ³ãƒãƒ« "${newChannel.name}" ã« ${channelData.messages.length} ä»¶ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å¾©å…ƒã—ã¾ã™ã€‚`
        );
        for (const msg of channelData.messages) {
          try {
            const messageEmbed = new EmbedBuilder()
              .setAuthor({
                name: msg.author.username,
                iconURL: msg.author.avatarURL,
              })
              .setDescription(msg.content || null)
              .setTimestamp(new Date(msg.timestamp));

            if (msg.embeds && msg.embeds.length > 0) {
              messageEmbed.addFields({
                name: 'å…ƒã®åŸ‹ã‚è¾¼ã¿',
                value: 'å¾©å…ƒã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ã¯ã€å…ƒã®åŸ‹ã‚è¾¼ã¿ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚‚å«ã¾ã‚Œã¦ã„ã¾ã—ãŸã€‚',
              });
            }

            if (msg.attachments && msg.attachments.length > 0) {
              messageEmbed.addFields({ name: 'æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«', value: msg.attachments.join('\n') });
            }

            await newChannel.send({ embeds: [messageEmbed] });
          } catch (err) {
            console.error(
              `[ã‚¨ãƒ©ãƒ¼] ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å¾©å…ƒä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ (ãƒãƒ£ãƒ³ãƒãƒ«: ${newChannel.name})`,
              err.message
            );
          }
        }
      }
    } catch (err) {
      console.error(
        `[ã‚¨ãƒ©ãƒ¼] ãƒãƒ£ãƒ³ãƒãƒ« "${channelData.name}" ã®ä½œæˆã¾ãŸã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å¾©å…ƒã«å¤±æ•—ã—ã¾ã—ãŸã€‚`,
        err.message
      );
    }
  }

  for (const threadData of threadChannelsData) {
    try {
      const parentChannel =
        createdChannels.get(threadData.parent) ||
        guild.channels.cache.find((c) => c.name === threadData.parent && c.isTextBased());
      if (parentChannel && parentChannel.threads) {
        const existingThread = parentChannel.threads.cache.find((t) => t.name === threadData.name);
        if (!existingThread) {
          console.log(
            `[å¾©å…ƒ] ã‚¹ãƒ¬ãƒƒãƒ‰ "${threadData.name}" ã‚’ãƒãƒ£ãƒ³ãƒãƒ« "${parentChannel.name}" ã«ä½œæˆã—ã¾ã™ã€‚`
          );
          await parentChannel.threads.create({
            name: threadData.name,
            type: threadData.type,
            autoArchiveDuration: 1440,
          });
        } else {
          console.log(`[å¾©å…ƒ] æ—¢å­˜ã®ã‚¹ãƒ¬ãƒƒãƒ‰ "${threadData.name}" ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚`);
        }
      } else {
        console.error(
          `[ã‚¨ãƒ©ãƒ¼] ã‚¹ãƒ¬ãƒƒãƒ‰ "${threadData.name}" ã®è¦ªãƒãƒ£ãƒ³ãƒãƒ« "${threadData.parent}" ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`
        );
      }
    } catch (err) {
      console.error(`[ã‚¨ãƒ©ãƒ¼] ã‚¹ãƒ¬ãƒƒãƒ‰ "${threadData.name}" ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚`, err.message);
    }
  }
  console.log('[å¾©å…ƒ] ãƒãƒ£ãƒ³ãƒãƒ«ã®å¾©å…ƒãŒå®Œäº†ã—ã¾ã—ãŸã€‚');
  console.log(`[å¾©å…ƒ] ã‚µãƒ¼ãƒãƒ¼ "${guild.name}" (ID: ${guild.id}) ã®å¾©å…ƒå‡¦ç†ãŒå®Œäº†ã—ã¾ã—ãŸã€‚`);
}

// --- ã‚³ãƒãƒ³ãƒ‰ã”ã¨ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ ---

async function handleHelpCommand(interaction) {
  const helpEmbed = new EmbedBuilder()
    .setColor(0x0099ff)
    .setTitle('ğŸ¤– Bot ã‚³ãƒãƒ³ãƒ‰ãƒ˜ãƒ«ãƒ—')
    .setDescription('ã“ã®BotãŒæä¾›ã™ã‚‹ã‚³ãƒãƒ³ãƒ‰ã®ä¸€è¦§ã¨èª¬æ˜ã§ã™ã€‚')
    .addFields(
      { name: '\nğŸ“œ ä¸€èˆ¬ã‚³ãƒãƒ³ãƒ‰', value: ' ' },
      { name: '/help', value: 'ã“ã®ãƒ˜ãƒ«ãƒ—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚' },
      { name: '/server', value: 'ã‚µãƒ¼ãƒãƒ¼ã®å„ç¨®æƒ…å ±ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚' },
      { name: '\nğŸ”§ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼†å¾©å…ƒã‚³ãƒãƒ³ãƒ‰ (è¦: ã‚µãƒ¼ãƒãƒ¼ã®ç®¡ç†æ¨©é™)', value: ' ' },
      {
        name: '/backup name:<ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å>',
        value: 'ç¾åœ¨ã®ã‚µãƒ¼ãƒãƒ¼æ§‹æˆã‚’ã€ã‚ãªãŸå°‚ç”¨ã®å€‹äººç”¨ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¨ã—ã¦ä¿å­˜ã—ã¾ã™ã€‚',
      },
      {
        name: '/restore name:<ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å>',
        value:
          'ã‚ãªãŸã®å€‹äººç”¨ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰ã‚µãƒ¼ãƒãƒ¼ã‚’å¾©å…ƒã—ã¾ã™ï¼ˆæ—¢å­˜ã®ãƒãƒ£ãƒ³ãƒãƒ«ã¯ç¶­æŒã•ã‚Œã¾ã™ï¼‰ã€‚',
      },
      {
        name: '/create-template',
        value:
          '**[å±é™º]** Botã‚ªãƒ¼ãƒŠãƒ¼ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã§ã‚µãƒ¼ãƒãƒ¼ã‚’å®Œå…¨ã«ä¸Šæ›¸ãã—ã¾ã™ã€‚ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã«ãªã„ãƒãƒ£ãƒ³ãƒãƒ«ã¯å…¨ã¦å‰Šé™¤ã•ã‚Œã¾ã™ã€‚',
      },
      {
        name: '/backup-manage action:<æ“ä½œ> [name:<ãƒ•ã‚¡ã‚¤ãƒ«å>]',
        value:
          'ã‚ãªãŸã®å€‹äººç”¨ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ã€ä¸€è¦§è¡¨ç¤ºã€ãƒ­ãƒƒã‚¯ã€å‰Šé™¤ãªã©ã‚’è¡Œã„ã¾ã™ã€‚ã€Œlistã€ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ãƒ•ã‚¡ã‚¤ãƒ«åã®æŒ‡å®šã¯ä¸è¦ã§ã™ã€‚',
      },
      {
        name: '/backuptimer schedule:<é »åº¦> time:<æ™‚é–“å¸¯> hour:<æ™‚> minute:<åˆ†>',
        value: 'ã‚µãƒ¼ãƒãƒ¼ã®è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¨­å®šã—ã¾ã™ã€‚',
      },
      {
        name: '/backuptimer-manage action:<æ“ä½œ>',
        value: 'ã‚µãƒ¼ãƒãƒ¼ã®è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ON/OFFã‚’åˆ‡ã‚Šæ›¿ãˆã¾ã™ã€‚',
      },
      {
        name: '/deletemessage user:<ãƒ¦ãƒ¼ã‚¶ãƒ¼> count:<ä»¶æ•°>',
        value:
          'æŒ‡å®šã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã€æŒ‡å®šã•ã‚ŒãŸä»¶æ•°ã ã‘å‰Šé™¤ã—ã¾ã™ã€‚(æœ€å¤§100ä»¶ã€14æ—¥ä»¥å†…ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã¿)',
      },
      { name: '\nâš ï¸ ã”åˆ©ç”¨ä¸Šã®æ³¨æ„', value: ' ' },
      {
        name: 'ğŸš¨ã€é‡è¦ã€‘æ¨©é™ã®è¨­å®š',
        value:
          '**ã“ã®Botã®ãƒ­ãƒ¼ãƒ«ãŒã€ç®¡ç†ã—ãŸã„å…¨ã¦ã®ãƒ­ãƒ¼ãƒ«ã‚ˆã‚Šä¸Šã«ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚** ãã†ã—ãªã„ã¨ã€æ¨©é™ä¸è¶³ã§ãƒ­ãƒ¼ãƒ«ã®å¾©å…ƒã«å¤±æ•—ã—ã¾ã™ã€‚',
      },
      {
        name: 'ã‚µãƒ¼ãƒãƒ¼ã®è¤‡è£½ã«ã¤ã„ã¦',
        value:
          'ã‚ã‚‹ã‚µãƒ¼ãƒãƒ¼ã§ `/backup` ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã€åˆ¥ã®ã‚µãƒ¼ãƒãƒ¼ã§ `/restore` ã™ã‚‹ã“ã¨ã§ã€ã‚µãƒ¼ãƒãƒ¼ã®æ§‹æˆï¼ˆãƒãƒ£ãƒ³ãƒãƒ«ã‚„ãƒ­ãƒ¼ãƒ«ï¼‰ã‚’è¤‡è£½ã§ãã¾ã™ã€‚',
      }
    )
    .setTimestamp()
    .setFooter({ text: 'Server Backup Bot' });

  await interaction.reply({ embeds: [helpEmbed], flags: MessageFlags.Ephemeral });
}

async function handleServerCommand(interaction) {
  await interaction.deferReply({ flags: MessageFlags.Ephemeral });
  const guild = interaction.guild;
  let members;
  try {
    await guild.members.fetch();
    members = guild.members.cache.map((m) => m.user.tag);
  } catch (err) {
    console.error('[ã‚¨ãƒ©ãƒ¼] ã‚µãƒ¼ãƒãƒ¼ãƒ¡ãƒ³ãƒãƒ¼ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚', err);
    return interaction.editReply({
      content:
        'ãƒ¡ãƒ³ãƒãƒ¼æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚Botã«ã€ŒServer Members Intentã€ã¨å¿…è¦ãªæ¨©é™ãŒã‚ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
      flags: MessageFlags.Ephemeral,
    });
  }
  const totalMembers = guild.memberCount;
  const pageSize = 10;
  const totalPages = Math.ceil(members.length / pageSize);
  let page = 0;

  const generateEmbed = (p) => {
    const slice = members.slice(p * pageSize, p * pageSize + pageSize);
    return new EmbedBuilder()
      .setColor(0x0099ff)
      .setTitle(guild.name)
      .setThumbnail(guild.iconURL({ dynamic: true }))
      .addFields(
        { name: 'ã‚µãƒ¼ãƒãƒ¼ID', value: guild.id, inline: true },
        { name: 'ä½œæˆæ—¥', value: guild.createdAt.toLocaleDateString(), inline: true },
        { name: 'ãƒ¡ãƒ³ãƒãƒ¼æ•°', value: `${totalMembers}`, inline: true },
        { name: 'ã‚ªãƒ¼ãƒŠãƒ¼', value: `<@${guild.ownerId}>`, inline: true },
        { name: 'ãƒãƒ£ãƒ³ãƒãƒ«æ•°', value: `${guild.channels.cache.size}`, inline: true },
        { name: 'ãƒ­ãƒ¼ãƒ«æ•°', value: `${guild.roles.cache.size}`, inline: true },
        { name: 'ãƒ–ãƒ¼ã‚¹ãƒˆãƒ¬ãƒ™ãƒ«', value: `${guild.premiumTier}`, inline: true },
        { name: 'ãƒ–ãƒ¼ã‚¹ãƒˆæ•°', value: `${guild.premiumSubscriptionCount}`, inline: true },
        {
          name: `ãƒ¡ãƒ³ãƒãƒ¼ä¸€è¦§ (ãƒšãƒ¼ã‚¸ ${p + 1}/${totalPages})`,
          value: slice.join('\n') || 'ãƒ¡ãƒ³ãƒãƒ¼ãŒã„ã¾ã›ã‚“ã€‚',
        }
      )
      .setTimestamp()
      .setFooter({ text: `Requested by ${interaction.user.tag}` });
  };

  const row = new ActionRowBuilder().addComponents(
    new ButtonBuilder()
      .setCustomId('previous_page')
      .setLabel('å‰ã¸')
      .setStyle(ButtonStyle.Primary)
      .setDisabled(true),
    new ButtonBuilder()
      .setCustomId('next_page')
      .setLabel('æ¬¡ã¸')
      .setStyle(ButtonStyle.Primary)
      .setDisabled(totalPages <= 1)
  );

  const message = await interaction.editReply({
    embeds: [generateEmbed(page)],
    components: [row],
    fetchReply: true,
    flags: MessageFlags.Ephemeral,
  });
  const collector = message.createMessageComponentCollector({ time: 60_000 });

  collector.on('collect', async (btn) => {
    if (btn.user.id !== interaction.user.id) {
      return btn.reply({ content: 'ã‚ãªãŸä»¥å¤–ã¯æ“ä½œã§ãã¾ã›ã‚“ã€‚', flags: MessageFlags.Ephemeral });
    }
    page += btn.customId === 'next_page' ? 1 : -1;
    row.components[0].setDisabled(page === 0);
    row.components[1].setDisabled(page === totalPages - 1);
    await btn.update({ embeds: [generateEmbed(page)], components: [row] });
  });

  collector.on('end', () => {
    row.components.forEach((c) => c.setDisabled(true));
    interaction.editReply({ components: [row] });
  });
}

async function executeBackup(guild, userId, backupName, isAuto = false) {
  let sanitizedName;
  if (isAuto) {
    const now = new Date();
    const yy = now.getFullYear().toString().slice(-2);
    const mm = (now.getMonth() + 1).toString().padStart(2, '0');
    const dd = now.getDate().toString().padStart(2, '0');
    const hh = now.getHours().toString().padStart(2, '0');
    const mi = now.getMinutes().toString().padStart(2, '0');
    sanitizedName = `auto_${yy}${mm}${dd}_${hh}${mi}`;
  } else {
    if (!backupName) throw new Error('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—åãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚');
    sanitizedName = backupName.replace(/[^a-zA-Z0-9_\\-]+/g, '');
    if (!sanitizedName) {
      throw new Error(
        'ç„¡åŠ¹ãªãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—åã§ã™ã€‚è‹±æ•°å­—ã€ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢(_)ã€ãƒã‚¤ãƒ•ãƒ³(-)ã®ã¿ä½¿ç”¨ã§ãã¾ã™ã€‚'
      );
    }
  }

  await ensureBackupDir(userId);
  const backupFileName = `${sanitizedName}.json`;
  const backupFilePath = path.join(getBackupDir(userId), backupFileName);

  const backupData = {
    serverName: guild.name,
    serverId: guild.id,
    createdAt: new Date().toISOString(),
    createdBy: userId,
    locked: isAuto ? true : false, // è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ãƒ­ãƒƒã‚¯
    roles: [],
    channels: [],
  };

  await guild.members.fetch();
  console.log('[ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—] ãƒ­ãƒ¼ãƒ«æƒ…å ±ã‚’åé›†ã—ã¦ã„ã¾ã™...');
  guild.roles.cache
    .filter((role) => role.name !== '@everyone')
    .sort((a, b) => b.position - a.position)
    .forEach((role) => {
      backupData.roles.push({
        name: role.name,
        color: role.hexColor,
        permissions: role.permissions.toString(),
        hoist: role.hoist,
        mentionable: role.mentionable,
        position: role.position,
        members: role.members.map((member) => member.id),
      });
    });
  console.log('[ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—] ãƒ­ãƒ¼ãƒ«æƒ…å ±ã®åé›†ãŒå®Œäº†ã—ã¾ã—ãŸã€‚');

  console.log('[ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—] ãƒãƒ£ãƒ³ãƒãƒ«æƒ…å ±ã¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å±¥æ­´ã‚’åé›†ã—ã¦ã„ã¾ã™...');
  const channelPromises = guild.channels.cache
    .sort((a, b) => a.position - b.position)
    .map(async (channel) => {
      const channelData = {
        name: channel.name,
        type: channel.type,
        parent: channel.parent ? channel.parent.name : null,
        position: channel.position,
        messages: [],
      };

      if (channel.isTextBased() && channel.type !== ChannelType.GuildVoice) {
        try {
          if (
            guild.members.me.permissionsIn(channel).has(PermissionsBitField.Flags.ViewChannel) &&
            guild.members.me
              .permissionsIn(channel)
              .has(PermissionsBitField.Flags.ReadMessageHistory)
          ) {
            const messages = await channel.messages.fetch({ limit: 30 });
            channelData.messages = messages
              .map((msg) => ({
                author: {
                  username: msg.author.username,
                  avatarURL: msg.author.displayAvatarURL(),
                },
                content: msg.content,
                embeds: msg.embeds,
                attachments: msg.attachments.map((a) => a.url),
                timestamp: msg.createdAt.toISOString(),
              }))
              .reverse();
          } else {
            console.log(
              `[ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—] ãƒãƒ£ãƒ³ãƒãƒ« "${channel.name}" ã®é–²è¦§ã¾ãŸã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å±¥æ­´ã®æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚`
            );
          }
        } catch (err) {
          console.error(
            `[ã‚¨ãƒ©ãƒ¼] ãƒãƒ£ãƒ³ãƒãƒ« "${channel.name}" ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å±¥æ­´ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚`,
            err.message
          );
        }
      }
      return channelData;
    });

  backupData.channels = await Promise.all(channelPromises);
  console.log('[ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—] ãƒãƒ£ãƒ³ãƒãƒ«æƒ…å ±ã¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å±¥æ­´ã®åé›†ãŒå®Œäº†ã—ã¾ã—ãŸã€‚');

  await fsp.writeFile(backupFilePath, JSON.stringify(backupData, null, 2));

  if (isAuto) {
    const backupDir = getBackupDir(userId);
    const allFiles = await fsp.readdir(backupDir);
    const autoBackups = allFiles
      .filter((file) => file.startsWith('auto_') && file.endsWith('.json'))
      .sort()
      .reverse();

    if (autoBackups.length > 3) {
      const filesToDelete = autoBackups.slice(3);
      for (const fileToDelete of filesToDelete) {
        try {
          await fsp.unlink(path.join(backupDir, fileToDelete));
          console.log(
            `[è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—] å¤ã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ« ${fileToDelete} ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚`
          );
        } catch (err) {
          console.error(
            `[ã‚¨ãƒ©ãƒ¼] å¤ã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ« ${fileToDelete} ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸã€‚`,
            err
          );
        }
      }
    }
  }

  return backupFileName;
}

async function handleBackupCommand(interaction) {
  await interaction.deferReply({ flags: MessageFlags.Ephemeral });
  const userId = interaction.user.id;
  const backupName = interaction.options.getString('name');

  try {
    const backupFileName = await executeBackup(interaction.guild, userId, backupName, false);
    await interaction.editReply({
      content: `ã‚µãƒ¼ãƒãƒ¼ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒå®Œäº†ã—ã¾ã—ãŸã€‚
ãƒ•ã‚¡ã‚¤ãƒ«: ${backupFileName}`,
      flags: MessageFlags.Ephemeral,
    });
  } catch (error) {
    console.error('[ã‚¨ãƒ©ãƒ¼] ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚', error);
    await interaction.editReply({
      content: `ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚è©³ç´°: ${error.message}`,
      flags: MessageFlags.Ephemeral,
    });
  }
}

async function handleRestoreCommand(interaction) {
  await interaction.deferReply({ flags: MessageFlags.Ephemeral });
  const userId = interaction.user.id;
  const backupName = interaction.options.getString('name');
  const backupFileName = `${backupName}.json`;
  const backupFilePath = path.join(getBackupDir(userId), backupFileName);

  try {
    await fsp.access(backupFilePath);
  } catch (error) {
    console.log(
      `[å¾©å…ƒ] ãƒ¦ãƒ¼ã‚¶ãƒ¼ ${interaction.user.tag} ãŒå­˜åœ¨ã—ãªã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ« "${backupFileName}" ã‚’æŒ‡å®šã—ã¾ã—ãŸã€‚`
    );
    return interaction.editReply({
      content: `ã‚ãªãŸã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${backupFileName}ã€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`,
      flags: MessageFlags.Ephemeral,
    });
  }

  try {
    const backupData = JSON.parse(await fsp.readFile(backupFilePath, 'utf-8'));
    await interaction.editReply({
      content: 'ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰ã‚µãƒ¼ãƒãƒ¼ã®å¾©å…ƒã‚’é–‹å§‹ã—ã¾ã™...',
      flags: MessageFlags.Ephemeral,
    });
    await applyBackup(interaction.guild, backupData, false);
    await interaction.followUp({
      content: `ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã€Œ${backupFileName}ã€ã‹ã‚‰ã®ã‚µãƒ¼ãƒãƒ¼ã®å¾©å…ƒãŒå®Œäº†ã—ã¾ã—ãŸã€‚`,
      flags: MessageFlags.Ephemeral,
    });
  } catch (error) {
    console.error('[ã‚¨ãƒ©ãƒ¼] å¾©å…ƒã«å¤±æ•—ã—ã¾ã—ãŸã€‚', error);
    await interaction.followUp({
      content: 'å¾©å…ƒã«å¤±æ•—ã—ã¾ã—ãŸã€‚Botã«å¿…è¦ãªæ¨©é™ãŒã‚ã‚‹ã‹ã€ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ­ã‚°ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
      flags: MessageFlags.Ephemeral,
    });
  }
}

async function handleCreateTemplateCommand(interaction) {
  await interaction.deferReply({ flags: MessageFlags.Ephemeral });

  const ownerId = '1068465891743899698';
  const backupName = 'template';
  const backupFileName = `${backupName}.json`;
  const backupFilePath = path.join(getBackupDir(ownerId), backupFileName);

  try {
    await fsp.access(backupFilePath);
  } catch (error) {
    console.log(
      `[ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ] ã‚ªãƒ¼ãƒŠãƒ¼ (ID: ${ownerId}) ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`
    );
    return interaction.editReply({
      content: `ã‚ªãƒ¼ãƒŠãƒ¼ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ« (${backupFileName}) ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`,
      flags: MessageFlags.Ephemeral,
    });
  }

  const confirmButton = new ButtonBuilder()
    .setCustomId('confirm_template')
    .setLabel('ã¯ã„ã€ä¸Šæ›¸ãã—ã¾ã™')
    .setStyle(ButtonStyle.Danger);
  const cancelButton = new ButtonBuilder()
    .setCustomId('cancel_template')
    .setLabel('ã„ã„ãˆã€ã‚„ã‚ã¾ã™')
    .setStyle(ButtonStyle.Secondary);
  const row1 = new ActionRowBuilder().addComponents(confirmButton, cancelButton);

  const warning1 = await interaction.editReply({
    content: `âš ï¸ **è­¦å‘Š: ã‚µãƒ¼ãƒãƒ¼ä¸Šæ›¸ã** âš ï¸\nã“ã®æ“ä½œã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€ã¾ãšãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®å†…å®¹ãŒå¾©å…ƒã•ã‚Œã€ãã®å¾Œã€**ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã«å­˜åœ¨ã—ãªã„å…¨ã¦ã®ãƒãƒ£ãƒ³ãƒãƒ«ãŒã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰å‰Šé™¤ã•ã‚Œã¾ã™ã€‚** ã“ã®æ“ä½œã¯å…ƒã«æˆ»ã›ã¾ã›ã‚“ã€‚\n\næœ¬å½“ã«ç¶šè¡Œã—ã¾ã™ã‹ï¼Ÿ`,
    components: [row1],
    fetchReply: true,
    flags: MessageFlags.Ephemeral,
  });

  try {
    const collectorFilter = (i) => i.user.id === interaction.user.id;
    const confirmation1 = await warning1.awaitMessageComponent({
      filter: collectorFilter,
      time: 30_000,
    });

    if (confirmation1.customId === 'cancel_template') {
      return confirmation1.update({ content: 'æ“ä½œã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚', components: [] });
    }

    const confirmButton2 = new ButtonBuilder()
      .setCustomId('confirm_final')
      .setLabel('ã¯ã„ã€å®Ÿè¡Œã—ã¾ã™')
      .setStyle(ButtonStyle.Danger);
    const cancelButton2 = new ButtonBuilder()
      .setCustomId('cancel_final')
      .setLabel('ã„ã„ãˆã€ã‚„ã¯ã‚Šä¸­æ­¢ã—ã¾ã™')
      .setStyle(ButtonStyle.Secondary);
    const row2 = new ActionRowBuilder().addComponents(confirmButton2, cancelButton2);

    await confirmation1.update({
      content:
        'ğŸš¨ **æœ€çµ‚ç¢ºèª** ğŸš¨\næœ¬å½“ã«ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ **ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã«ãªã„ãƒãƒ£ãƒ³ãƒãƒ«ã¯ã€ã“ã®ã‚³ãƒãƒ³ãƒ‰ã‚’æ‰“ã£ãŸãƒãƒ£ãƒ³ãƒãƒ«ã‚‚å«ã‚ã¦å…¨ã¦å‰Šé™¤ã•ã‚Œã¾ã™ã€‚**',
      components: [row2],
    });

    const confirmation2 = await warning1.awaitMessageComponent({
      filter: collectorFilter,
      time: 30_000,
    });

    if (confirmation2.customId === 'cancel_final') {
      return confirmation2.update({ content: 'æ“ä½œã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚', components: [] });
    }

    await confirmation2.update({
      content: 'ç¢ºèªãŒå–ã‚Œã¾ã—ãŸã€‚ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’é©ç”¨ã—ã€å®Œäº†å¾Œã«ä¸è¦ãªãƒãƒ£ãƒ³ãƒãƒ«ã‚’å‰Šé™¤ã—ã¾ã™...',
      components: [],
    });

    const backupData = JSON.parse(await fsp.readFile(backupFilePath, 'utf-8'));
    const guild = interaction.guild;

    await interaction.followUp({
      content: 'ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®é©ç”¨ã‚’é–‹å§‹ã—ã¾ã™...',
      flags: MessageFlags.Ephemeral,
    });
    await applyBackup(guild, backupData, true);
    await interaction.followUp({
      content: 'ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®é©ç”¨ãŒå®Œäº†ã—ã¾ã—ãŸã€‚',
      flags: MessageFlags.Ephemeral,
    });

    await interaction.followUp({
      content: 'ä¸è¦ãªãƒãƒ£ãƒ³ãƒãƒ«ã®å‰Šé™¤ã‚’é–‹å§‹ã—ã¾ã™...',
      flags: MessageFlags.Ephemeral,
    });
    const backupChannelNames = new Set(backupData.channels.map((c) => c.name));
    const interactionChannelId = interaction.channelId;

    await guild.channels.fetch();

    const channelsToDelete = guild.channels.cache.filter(
      (channel) => !backupChannelNames.has(channel.name) && channel.id !== interactionChannelId
    );

    console.log(`[ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ] ${channelsToDelete.size}å€‹ã®ä¸è¦ãªãƒãƒ£ãƒ³ãƒãƒ«ã‚’å‰Šé™¤ã—ã¾ã™ã€‚`);
    for (const channel of channelsToDelete.values()) {
      try {
        await channel.delete('Template overwrite cleanup');
        console.log(`[ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ] ãƒãƒ£ãƒ³ãƒãƒ« "${channel.name}" ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚`);
      } catch (err) {
        console.error(
          `[ã‚¨ãƒ©ãƒ¼] ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ä¸­ã«ãƒãƒ£ãƒ³ãƒãƒ« "${channel.name}" ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸã€‚`,
          err
        );
      }
    }

    const interactionChannel = guild.channels.cache.get(interactionChannelId);
    if (interactionChannel && !backupChannelNames.has(interactionChannel.name)) {
      try {
        await interaction.followUp({
          content: 'æœ€å¾Œã«ã€ã“ã®å¿œç­”ç”¨ãƒãƒ£ãƒ³ãƒãƒ«ã‚’å‰Šé™¤ã—ã¾ã™ã€‚',
          flags: MessageFlags.Ephemeral,
        });
        await interactionChannel.delete('Template overwrite cleanup');
        console.log(
          `[ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ] å¿œç­”ç”¨ãƒãƒ£ãƒ³ãƒãƒ« "${interactionChannel.name}" ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚`
        );
      } catch (err) {
        console.error(
          `[ã‚¨ãƒ©ãƒ¼] å¿œç­”ç”¨ãƒãƒ£ãƒ³ãƒãƒ« "${interactionChannel.name}" ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸã€‚`,
          err
        );
      }
    }
  } catch (err) {
    console.error('[ã‚¨ãƒ©ãƒ¼] ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆé©ç”¨ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', err);
    await interaction.editReply({
      content: 'ç¢ºèªãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ãŸã‹ã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸãŸã‚æ“ä½œã‚’ä¸­æ­¢ã—ã¾ã—ãŸã€‚',
      components: [],
    });
  }
}

async function handleBackupManageCommand(interaction) {
  await interaction.deferReply({ flags: MessageFlags.Ephemeral });
  const action = interaction.options.getString('action');
  const fileName = interaction.options.getString('name');
  const userId = interaction.user.id;
  const backupDir = getBackupDir(userId);

  try {
    await ensureBackupDir(userId);

    if (action === 'list') {
      if (fileName) {
        await interaction.followUp({
          content:
            'ã€Œlistã€ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ãƒ•ã‚¡ã‚¤ãƒ«åã®æŒ‡å®šã¯ä¸è¦ã§ã™ã€‚å…¨ã¦ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚',
        });
      }
      const files = await fsp.readdir(backupDir);
      const backupFiles = files.filter((file) => file.endsWith('.json'));

      if (backupFiles.length === 0) {
        return interaction.editReply({
          content: 'ã‚ãªãŸã«ã¯ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚',
          flags: MessageFlags.Ephemeral,
        });
      }

      const fileListPromises = backupFiles.map(async (file) => {
        try {
          const filePath = path.join(backupDir, file);
          const data = await fsp.readFile(filePath, 'utf-8');
          const json = JSON.parse(data);
          const serverInfo = json.serverName ? `(${json.serverName})` : '';
          return json.locked ? `ğŸ”’ \`${file}\` ${serverInfo}` : `âœ… \`${file}\` ${serverInfo}`;
        } catch {
          return `âŒ \`${file}\` (èª­ã¿å–ã‚Šä¸å¯)`;
        }
      });

      const fileList = (await Promise.all(fileListPromises)).join('\n');
      const embed = new EmbedBuilder()
        .setColor(0x0099ff)
        .setTitle('ã‚ãªãŸã®å€‹äººç”¨ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä¸€è¦§')
        .setDescription(fileList || 'ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚')
        .setTimestamp();
      await interaction.editReply({ embeds: [embed], flags: MessageFlags.Ephemeral });
    } else {
      if (!fileName) {
        return interaction.reply({
          content: 'ã“ã®æ“ä½œã«ã¯ãƒ•ã‚¡ã‚¤ãƒ«åã®æŒ‡å®šãŒå¿…è¦ã§ã™ã€‚',
          flags: MessageFlags.Ephemeral,
        });
      }
      const backupFileName = `${fileName}.json`;
      const backupFilePath = path.join(backupDir, backupFileName);

      try {
        await fsp.access(backupFilePath);
      } catch (error) {
        return interaction.editReply({
          content: `ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${backupFileName}ã€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`,
          flags: MessageFlags.Ephemeral,
        });
      }

      const fileData = await fsp.readFile(backupFilePath, 'utf-8');
      const backupJson = JSON.parse(fileData);

      if (action === 'lock') {
        if (backupJson.locked) {
          return interaction.editReply({
            content: `ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${backupFileName}ã€ã¯æ—¢ã«ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã¾ã™ã€‚`,
            flags: MessageFlags.Ephemeral,
          });
        }
        backupJson.locked = true;
        await fsp.writeFile(backupFilePath, JSON.stringify(backupJson, null, 2));
        console.log(
          `[ç®¡ç†] ãƒ¦ãƒ¼ã‚¶ãƒ¼ ${interaction.user.tag} ãŒãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ« "${backupFileName}" ã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã—ãŸã€‚`
        );
        await interaction.editReply({
          content: `ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${backupFileName}ã€ã‚’ãƒ­ãƒƒã‚¯ã—ã¾ã—ãŸã€‚`,
          flags: MessageFlags.Ephemeral,
        });
      } else if (action === 'unlock') {
        if (!backupJson.locked) {
          return interaction.editReply({
            content: `ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${backupFileName}ã€ã¯ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚`,
            flags: MessageFlags.Ephemeral,
          });
        }
        backupJson.locked = false;
        await fsp.writeFile(backupFilePath, JSON.stringify(backupJson, null, 2));
        console.log(
          `[ç®¡ç†] ãƒ¦ãƒ¼ã‚¶ãƒ¼ ${interaction.user.tag} ãŒãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ« "${backupFileName}" ã®ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã¾ã—ãŸã€‚`
        );
        await interaction.editReply({
          content: `ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${backupFileName}ã€ã®ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã¾ã—ãŸã€‚`,
          flags: MessageFlags.Ephemeral,
        });
      } else if (action === 'delete') {
        if (backupJson.locked) {
          console.log(
            `[ç®¡ç†] ãƒ¦ãƒ¼ã‚¶ãƒ¼ ${interaction.user.tag} ãŒãƒ­ãƒƒã‚¯ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ« "${backupFileName}" ã®å‰Šé™¤ã‚’è©¦ã¿ã¾ã—ãŸã€‚`
          );
          return interaction.editReply({
            content: `ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${backupFileName}ã€ã¯ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹ãŸã‚å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚`,
            flags: MessageFlags.Ephemeral,
          });
        }
        await fsp.unlink(backupFilePath);
        console.log(
          `[ç®¡ç†] ãƒ¦ãƒ¼ã‚¶ãƒ¼ ${interaction.user.tag} ãŒãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ« "${backupFileName}" ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚`
        );
        await interaction.editReply({
          content: `ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${backupFileName}ã€ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚`,
          flags: MessageFlags.Ephemeral,
        });
      }
    }
  } catch (error) {
    console.error(`[ã‚¨ãƒ©ãƒ¼] ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç®¡ç†ã‚³ãƒãƒ³ãƒ‰ (${action}) ã®å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸã€‚`, error);
    await interaction.editReply({
      content: 'æ“ä½œã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ­ã‚°ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
      flags: MessageFlags.Ephemeral,
    });
  }
}

async function handleDeleteMessageCommand(interaction) {
  await interaction.deferReply({ flags: MessageFlags.Ephemeral });

  const targetUser = interaction.options.getUser('user');
  const deleteCount = interaction.options.getInteger('count');
  const guild = interaction.guild;
  const member = await guild.members.fetch(interaction.user.id);
  const channel = interaction.channel;

  if (!member.permissions.has(PermissionsBitField.Flags.ManageMessages)) {
    return interaction.editReply({
      content: 'ã“ã®ã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã«ã¯ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ç®¡ç†æ¨©é™ãŒå¿…è¦ã§ã™ã€‚',
      flags: MessageFlags.Ephemeral,
    });
  }

  if (!targetUser || !deleteCount) {
    return interaction.editReply({
      content: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¨å‰Šé™¤ä»¶æ•°ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚',
      flags: MessageFlags.Ephemeral,
    });
  }

  if (!channel.isTextBased()) {
    return interaction.editReply({
      content: 'ã“ã®ã‚³ãƒãƒ³ãƒ‰ã¯ãƒ†ã‚­ã‚¹ãƒˆãƒãƒ£ãƒ³ãƒãƒ«ã§ã®ã¿ä½¿ç”¨ã§ãã¾ã™ã€‚',
      flags: MessageFlags.Ephemeral,
    });
  }

  const twoWeeksAgo = Date.now() - 14 * 24 * 60 * 60 * 1000;
  let deletedMessagesCount = 0;

  try {
    console.log(
      `[å‰Šé™¤] ãƒãƒ£ãƒ³ãƒãƒ« "${channel.name}" (ID: ${channel.id}) ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‰Šé™¤å‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™ã€‚`
    );
    const messages = await channel.messages.fetch({ limit: 100 });
    const userMessages = messages.filter(
      (m) => m.author.id === targetUser.id && m.createdTimestamp > twoWeeksAgo
    );

    const messagesToDelete = Array.from(userMessages.values()).slice(0, deleteCount);
    if (messagesToDelete.length > 0) {
      const deleted = await channel.bulkDelete(messagesToDelete, true);
      deletedMessagesCount = deleted.size;
    }

    console.log(
      `[å‰Šé™¤] ãƒ¦ãƒ¼ã‚¶ãƒ¼ "${targetUser.tag}" ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ ${deletedMessagesCount} ä»¶å‰Šé™¤ã—ã¾ã—ãŸã€‚`
    );
    await interaction.editReply({
      content: `ãƒ¦ãƒ¼ã‚¶ãƒ¼ã€Œ${targetUser.tag}ã€ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ ${deletedMessagesCount} ä»¶å‰Šé™¤ã—ã¾ã—ãŸã€‚`,
      flags: MessageFlags.Ephemeral,
    });
  } catch (error) {
    console.error('[ã‚¨ãƒ©ãƒ¼] ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', error);
    await interaction.editReply({
      content: 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ­ã‚°ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
      flags: MessageFlags.Ephemeral,
    });
  }
}

async function saveSchedules() {
  const serializableSchedules = new Map();
  for (const [guildId, schedule] of backupSchedules.entries()) {
    const { task, ...serializableSchedule } = schedule;
    serializableSchedules.set(guildId, serializableSchedule);
  }
  const data = JSON.stringify(Array.from(serializableSchedules.entries()), null, 2);
  await fsp.writeFile(schedulesFilePath, data);
}

async function loadSchedules() {
  try {
    await fsp.access(schedulesFilePath);
    const data = await fsp.readFile(schedulesFilePath, 'utf-8');
    const schedules = new Map(JSON.parse(data));
    for (const [guildId, schedule] of schedules.entries()) {
      const guild = await client.guilds.fetch(guildId);
      if (guild) {
        const task = cron.schedule(schedule.cronString, async () => {
          // eslint-disable-line no-unused-vars
          console.log(`[è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—] ã‚µãƒ¼ãƒãƒ¼ "${guild.name}" ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’é–‹å§‹ã—ã¾ã™ã€‚`);
          try {
            await executeBackup(guild, schedule.userId, null, true);
            console.log(
              `[è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—] ã‚µãƒ¼ãƒãƒ¼ "${guild.name}" ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒå®Œäº†ã—ã¾ã—ãŸã€‚`
            );
          } catch (error) {
            console.error(
              `[ã‚¨ãƒ©ãƒ¼] è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã«å¤±æ•—ã—ã¾ã—ãŸ (ã‚µãƒ¼ãƒãƒ¼: ${guild.name})`,
              error
            );
          }
        });
        backupSchedules.set(guildId, { ...schedule, task });
      }
    }
    console.log('[èµ·å‹•] ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚');
  } catch (error) {
    if (error.code === 'ENOENT') {
      console.log('[èµ·å‹•] ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚æ–°ã—ãä½œæˆã—ã¾ã™ã€‚');
    } else {
      console.error('[ã‚¨ãƒ©ãƒ¼] ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚', error);
    }
  }
}

async function handleBackupTimerCommand(interaction) {
  await interaction.deferReply({ flags: MessageFlags.Ephemeral });

  const schedule = interaction.options.getString('schedule'); // eslint-disable-line no-unused-vars
  const time = interaction.options.getString('time');
  const hour = interaction.options.getInteger('hour');
  const minute = interaction.options.getInteger('minute');
  const guild = interaction.guild;
  const userId = interaction.user.id;

  let cronHour = hour;
  if (time === 'PM' && hour < 12) {
    cronHour += 12;
  }
  if (time === 'AM' && hour === 12) {
    cronHour = 0;
  }

  const cronString = `${minute} ${cronHour} * * *`;

  if (backupSchedules.has(guild.id)) {
    const existingTask = backupSchedules.get(guild.id).task;
    if (existingTask) {
      existingTask.stop();
    }
  }

  const task = cron.schedule(cronString, async () => {
    console.log(`[è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—] ã‚µãƒ¼ãƒãƒ¼ "${guild.name}" ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’é–‹å§‹ã—ã¾ã™ã€‚`);
    try {
      await executeBackup(guild, userId, null, true);
      console.log(`[è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—] ã‚µãƒ¼ãƒãƒ¼ "${guild.name}" ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒå®Œäº†ã—ã¾ã—ãŸã€‚`);
    } catch (error) {
      console.error(`[ã‚¨ãƒ©ãƒ¼] è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã«å¤±æ•—ã—ã¾ã—ãŸ (ã‚µãƒ¼ãƒãƒ¼: ${guild.name})`, error);
    }
  });

  backupSchedules.set(guild.id, { cronString, userId, task });
  await saveSchedules();

  await interaction.editReply({
    content: `è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã—ã¾ã—ãŸ: ${cronString}`,
    flags: MessageFlags.Ephemeral,
  });
}

async function handleBackupTimerManageCommand(interaction) {
  await interaction.deferReply({ flags: MessageFlags.Ephemeral });
  const action = interaction.options.getString('action');
  const guildId = interaction.guild.id;

  if (action === 'on') {
    const scheduleData = backupSchedules.get(guildId);
    if (scheduleData) {
      if (scheduleData.task && scheduleData.task.running) {
        return interaction.editReply({ content: 'è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¯æ—¢ã«ONã«ãªã£ã¦ã„ã¾ã™ã€‚' });
      }
      // ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåœæ­¢ã—ã¦ã„ã‚‹ã‹ã€ã‚¿ã‚¹ã‚¯ãŒãªã„å ´åˆã¯å†é–‹
      const task = cron.schedule(scheduleData.cronString, async () => {
        console.log(
          `[è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—] ã‚µãƒ¼ãƒãƒ¼ "${interaction.guild.name}" ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’é–‹å§‹ã—ã¾ã™ã€‚`
        );
        try {
          await executeBackup(interaction.guild, scheduleData.userId, null, true);
          console.log(
            `[è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—] ã‚µãƒ¼ãƒãƒ¼ "${interaction.guild.name}" ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒå®Œäº†ã—ã¾ã—ãŸã€‚`
          );
        } catch (error) {
          console.error(
            `[ã‚¨ãƒ©ãƒ¼] è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã«å¤±æ•—ã—ã¾ã—ãŸ (ã‚µãƒ¼ãƒãƒ¼: ${interaction.guild.name})`,
            error
          );
        }
      });
      backupSchedules.set(guildId, { ...scheduleData, task });
      await saveSchedules();
      await interaction.editReply({ content: 'è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ONã«ã—ã¾ã—ãŸã€‚' });
    } else {
      await interaction.editReply({
        content:
          'ã“ã®ã‚µãƒ¼ãƒãƒ¼ã«ã¯è¨­å®šã•ã‚ŒãŸè‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒã‚ã‚Šã¾ã›ã‚“ã€‚/backuptimer ã‚³ãƒãƒ³ãƒ‰ã§è¨­å®šã—ã¦ãã ã•ã„ã€‚',
      });
    }
  } else if (action === 'off') {
    const scheduleData = backupSchedules.get(guildId);
    if (scheduleData && scheduleData.task) {
      scheduleData.task.stop();
      backupSchedules.delete(guildId);
      await saveSchedules();
      await interaction.editReply({ content: 'è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’OFFã«ã—ã¾ã—ãŸã€‚' });
    }
  } else if (action === 'list') {
    const schedules = Array.from(backupSchedules.entries());
    if (schedules.length === 0) {
      return interaction.editReply({
        content: 'ã“ã®ã‚µãƒ¼ãƒãƒ¼ã«ã¯è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚',
      });
    }

    let description = '';
    for (const [guildId, scheduleData] of schedules) {
      const guild = client.guilds.cache.get(guildId);
      const guildName = guild ? guild.name : 'ä¸æ˜ãªã‚µãƒ¼ãƒãƒ¼';
      description += `**ã‚µãƒ¼ãƒãƒ¼:** ${guildName} (ID: ${guildId})\n`;
      description += `  **ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«:** ${scheduleData.cronString}\n`;
      description += `  **è¨­å®šè€…ID:** ${scheduleData.userId}\n`;
      description += `  **ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹:** ${scheduleData.task && scheduleData.task.running ? 'ON' : 'OFF'}\n`;
      description += '--------------------\n';
    }

    const embed = new EmbedBuilder()
      .setColor(0x0099ff)
      .setTitle('è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ä¸€è¦§')
      .setDescription(description)
      .setTimestamp();

    await interaction.editReply({ embeds: [embed], flags: MessageFlags.Ephemeral });
  }
}

process.on('unhandledRejection', (reason) => {
  console.error('[ã‚¨ãƒ©ãƒ¼] æœªå‡¦ç†ã®Promise rejection:', reason);
});

client.login(process.env.DISCORD_TOKEN);
